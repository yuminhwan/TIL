의존성이 강하게 결합될 수 록 코드 변경이 어렵고 테스트도 어려워짐 
유연한 설계가 좋음. 

해당 코드는 이메일을 보내기 위한 의존성이 많다. -> 강하게 결합되어 있다. 

복잡한 서브 시스템 의존성을  최소화하는 방법 

클라이언트가 사용해야 하는 복잡한 서브 시스템(라이브러리, 프레임워크 등) 의존성을 간단한 인터페이스로 추상화할 수 있다.



---

메일의 설정, 메시지, 보내는 객체

라이브러리에 대한 구체적인 의존성은 사라지지만 클래스에 대한 의존성은 어쩔 수 없다.
유연해진다? -> 테스트에서 Mocking 하기도 쉽고 EmailSender의 경우 인터페이스로 만든다면 JavaEmailSender와 같은 구현체를 만들어 자바 기술만으로 이메일을 보내는 객체로 만들 수 있고 외부 API를 쓴다면 해당 서비스의 EmailSender를 만들 수 있다.


조삼모사가 아닌가? 
여러곳에서 사용한다면? -> 한 곳에서만 모아놨기 때문에 변경 범위가 적다. 

### 장점 
- 서브 시스템에 대한 의존성을 한곳으로 모을 수 있다. 

### 단점 
- 퍼사드 클래스가 서브 시스템에 대한 모든 의존성을 가지게 된다.

클라이언트 입장에서 코드를 읽는 게 편하다면? 의미 있다. 
서브 시스템에 대한 깊은 이해가 필요 -> 추상화를 해놓는다면 ? -> 클라이언트에서는 간략하게 사용가능하다.


## 스프링에서는 어떻게 사용되나?
- org.springframework.mail.MailSender 
	- 클라이언트는 MailSender만 알지만 실질적인 사용하는 클래스는 JavaMailSenderImpl
- PlatformTransactionManager
	- JDBC, hibernate 등에 따라 트랜잭션 처리가 달라져야 한다. 해당 코드들을 이 인터페이스 뒤로 숨긴다. JDBC -> JdbcTransactionManager
	- PlatformTransactionManager는 비종속적인 인터페이스 
- Spring MVC 자체 
	- 자바가 제공하는 서블릿을 감싸는 퍼사드 
	- 5버전 이후로는 MVC != 서블릿이다. 
		- WebFlux에서도 MVC의 어노테이션들을 그대로 사용 가능하기 때문에
		- 
Spring이 제공하는 대부분의 인터페이스들 (특정 기술에 특화되어 있는 구현체를 감싸고 있는 )이 모두 퍼사드로 볼 수 도 있다.